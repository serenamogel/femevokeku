<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=description content="Prior to the iPhone 5s launch, I heard a rumor that Apple would move to a 64-bit architecture with its A7 SoC. I initially discounted the rumor given the pain of moving to 64-bit from a validation standpoint and the upside not being worth it. Obviously, I was wrong."><meta name=author content="Aldo Pusey"><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=robots content="index,follow,noarchive"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/base16/css/style.css type=text/css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type=text/css><link rel=alternate href=./index.xml type=application/rss+xml title=ZingW><title>The Move to 64-bit - The iPhone 5s Review - ZingW</title></head><body><header><div class="container clearfix"><a class=path href=./index.html>[ZingW]</a>
<span class=caret># _</span><div class=right></div></div></header><div class=container><main role=main class=article><article class=single itemscope itemtype=http://schema.org/BlogPosting><div class=meta><span class=key>published on</span>
<span class=val><time itemprop=datePublished datetime=2024-06-03>June 03, 2024</time></span>
<span class=key>in</span>
<span class=val><a href=./categories/blog>blog</a></span></div><h1 class=headline itemprop=headline>The Move to 64-bit - The iPhone 5s Review</h1><section class=body itemprop=articleBody><h2>The Move to 64-bit</h2><p>Prior to the iPhone 5s launch, I heard a rumor that Apple would move to a 64-bit architecture with its A7 SoC. I initially discounted the rumor given the pain of moving to 64-bit from a validation standpoint and the upside not being worth it. Obviously, I was wrong.</p><p>In the PC world, most users are familiar with the 64-bit transition as something AMD started in the mid-2000s. The primary motivation back then was to enable greater memory addressability by moving from 32-bit addresses (2^32 or 4GB) to 64-bit addresses (2^64 or 16EB). Supporting up to 16 exabytes of memory from the get go seemed a little unnecessary, so AMD’s x86-64 ISA only uses 48-bits for unique memory addresses (256TB of memory). Along with the move from x86 to x86-64 came some small performance enhancements thanks to more available general purpose registers in 64-bit mode.</p><p>In the ARM world, the move to 64-bit is motivated primarily by the same factor: a desire for more memory. Remember that ARM and its partners have high hopes of eating into Intel’s high margin server business, and you really can’t play there without 64-bit support. ARM has already announced its first two 64-bit architectures: the Cortex A57 and Cortex A53. The ISA itself is referred to as ARMv8, a logical successor to the present day 32-bit ARMv7.</p><p>Unlike the 64-bit x86 transition, ARM’s move to 64-bit comes with a new ISA rather than an extension of the old one. The new instruction set is referred to as A64, while a largely backwards compatible 32-bit format is called A32. Both ISAs can be supported by a single microprocessor design, as ARMv8 features two architectural states: AArch32 and AArch64. Designs that implement both states can switch/interleave between the two states on exception boundaries. In other words, despite A64 being a new ISA you’ll still be able to run old code alongside it. As always, in order to support both you need an OS with support for A64. You can’t run A64 code on an A32 OS. It is also possible to do an A64/AArch64-only design, which is something some server players are considering where backwards compatibility isn’t such a big deal.</p><p>Cyclone is a full implementation of ARMv8 with both AArch32 and AArch64 states. Given Apple’s desire to maintain backwards compatibility with existing iOS apps and not unnecessarily fragment the ARM ecosystem, simply embracing ARMv8 makes a lot of sense.</p><p>The motivation for Apple to go 64-bit isn’t necessarily one of needing more address space immediately. A look at Apple’s historical scaling of memory capacity tells us everything we need to know:</p><p align=center><a href=#><img height=420 src=https://cdn.statically.io/img/images.anandtech.com/reviews/smartphones/apple/iPhone5s/memcapacitysm.png width=678 style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>At best Apple doubled memory capacity between generations, and at worst it took two generations before doubling. The iPhone 5s ships with 1GB of LPDDR3, keeping memory capacity the same as the iPhone 5, iPad 3 and iPad 4. It’s pretty safe to assume that Apple will go to 2GB with the iPhone 6 (and perhaps iPad 5), and then either stay there for the 6s or double again to 4GB. The soonest Apple would need 64-bit from a memory addressability standpoint in an iOS device would be 2015, and the latest would be 2016. Moving to 64-bit now preempts Apple’s hardware needs by 2 full years.</p><p>The more I think about it, the more the timing actually makes a lot of sense. The latest Xcode beta and LLVM compiler are both ARMv8 aware. Presumably all apps built starting with the official iOS 7 release and going forward could be built 64-bit aware. By the time 2015/2016 rolls around and Apple starts bumping into 32-bit addressability concerns, not only will it have navigated the OS transition but a huge number of apps will already be built for 64-bit. Apple tends to do well with these sorts of transitions, so starting early like this isn’t unusual. The rest of the ARM ecosystem is expected to begin moving to ARMv8 next year.</p><p>Apple isn’t very focused on delivering a larger memory address space today however. As A64 is a brand new ISA, there are other benefits that come along with the move. Similar to the x86-64 transition, the move to A64 comes with an increase in the number of general purpose registers. ARMv7 had 15 general purpose registers (and 1 register for the program counter), while ARMv8/A64 now has 31 that are each 64-bits wide. All 31 registers are accessible at all times. Increasing the number of architectural registers decreases register pressure and can directly impact performance. The doubling of the register space with x86-64 was responsible for up to a 10% increase in performance.</p><p>The original ARM architecture made all instructions conditional, which had a huge impact on the instruction space. The number of conditional instructions is far more limited in ARMv8/A64.</p><p>The move to ARMv8 also doubles the number of FP/NEON registers (from 16 to 32) as well as widens all of them registers to 128-bits (up from 64-bits). Support for 128-bit registers can go a long way in improving SIMD performance. Whereas simply doubling register count can provide moderate increases in performance, doubling the size of each register can be far more significant given the right workload. There are also new advanced SIMD instructions that are a part of ARMv8. Double precision SIMD FP math is now supported among other things.</p><p>ARMv8 also adds some new cryptographic instructions for hardware acceleration of AES and SHA1/SHA256 algorithms. These hardware AES/SHA instructions have the potential for huge increases in performance, just like we saw with the introduction of AES-NI on Intel CPUs a few years back. Both the new advanced SIMD instructions and AES/SHA instructions are really designed to enable a new wave of iOS apps.</p><p>Many A64 instructions mode can also work with 32-bit operands, with properly implemented designs simply power gating unused bits. The A32 implementation in ARMv8 also adds some new instructions, so it’s possible to compile AArch32 apps in ARMv8 that aren’t backwards compatible. All existing ARMv7 and 32-bit Thumb code should work just fine however.</p><p>On the software side, iOS 7 as well as all first party apps ship already compiled for AArch64 operation. In fact, at boot, there isn’t a single AArch32 process running on the iPhone 5s:</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/7335/Screen%20Shot%202013-09-13%20at%2010.51.43%20AM_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Safari, Mail, everything all made the move to 64-bit right away. Given the popularity of these first party apps, it’s not just the hardware that’s 64-bit ready but much of the software is as well. The industry often speaks about Apple’s vertically integrated advantage, this is quite possibly the best example of that advantage. In many ways it reminds me of the Retina Display transition on OS X.</p><p>Running A32 and A64 applications in parallel is seamless. On the phone itself, it’s impossible to tell when you’re running in a mixed environment or when everything you’re running is 64-bit. It all just works.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/7335/Screen%20Shot%202013-09-13%20at%2010.51.53%20AM_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>I didn’t run into any backwards compatibility issues with existing 32-bit ARMv7 apps either. From an end user perspective, navigating the 64-bit transition is as simple as buying an iPhone 5s.</p><h2>64-bit Performance Gains</h2><p>Geekbench 3 was among the first apps to be updated with ARMv8 support. There are some minor changes between the new version of Geekbench 3 and its predecessor (3.1/3.0), however the tests themselves (except for the memory benchmarks) haven't changed. What this allows us to do is look at the impact of the new ARMv8 A64 instructions and larger register space. We'll start with a look at integer performance:</p><table align=center border=0 cellpadding=0 cellspacing=1 width=575><tbody readability=1><tr class=tgrey readability=2><td align=center colspan=7>Apple A7 - AArch64 vs. AArch32 Performance Comparison</td></tr><tr class=tlblue><td width=120>&nbsp;</td><td align=center valign=middle width=85>32-bit A32</td><td align=center valign=middle width=85>64-bit A64</td><td align=center valign=middle width=85>% Advantage</td></tr><tr><td class=tlgrey>AES</td><td align=center valign=middle>91.5 MB/s</td><td align=center valign=middle>846.2 MB/s</td><td align=center valign=middle>825%</td></tr><tr><td class=tlgrey>AES MT</td><td align=center valign=middle>180.2 MB/s</td><td align=center valign=middle>1640.0 MB/s</td><td align=center valign=middle>810%</td></tr><tr><td class=tlgrey>Twofish</td><td align=center valign=middle>59.9 MB/s</td><td align=center valign=middle>55.6 MB/s</td><td align=center valign=middle>-8%</td></tr><tr><td class=tlgrey>Twofish MT</td><td align=center valign=middle>119.1 MB/s</td><td align=center valign=middle>110.2 MB/s</td><td align=center valign=middle>-8%</td></tr><tr><td class=tlgrey>SHA1</td><td align=center valign=middle>138.0 MB/s</td><td align=center valign=middle>477.3 MB/s</td><td align=center valign=middle>245%</td></tr><tr><td class=tlgrey>SHA1 MT</td><td align=center valign=middle>275.7 MB/s</td><td align=center valign=middle>948.9 MB/s</td><td align=center valign=middle>244%</td></tr><tr><td class=tlgrey>SHA2</td><td align=center valign=middle>86.1 MB/s</td><td align=center valign=middle>102.2 MB/s</td><td align=center valign=middle>18%</td></tr><tr><td class=tlgrey>SHA2 MT</td><td align=center valign=middle>171.3 MB/s</td><td align=center valign=middle>203.7 MB/s</td><td align=center valign=middle>18%</td></tr><tr><td class=tlgrey>BZip2 Compress</td><td align=center valign=middle>4.36 MB/s</td><td align=center valign=middle>4.52 MB/s</td><td align=center valign=middle>3%</td></tr><tr><td class=tlgrey>BZip2 Compress MT</td><td align=center valign=middle>8.57 MB/s</td><td align=center valign=middle>8.86 MB/s</td><td align=center valign=middle>3%</td></tr><tr><td class=tlgrey>BZip2 Decompress</td><td align=center valign=middle>5.94 MB/s</td><td align=center valign=middle>7.56 MB/s</td><td align=center valign=middle>27%</td></tr><tr><td class=tlgrey>BZip2 Decompress MT</td><td align=center valign=middle>11.7 MB/s</td><td align=center valign=middle>15.0 MB/s</td><td align=center valign=middle>28%</td></tr><tr><td class=tlgrey>JPEG Compress</td><td align=center valign=middle>15.5 MPixels/s</td><td align=center valign=middle>16.8 MPixels/s</td><td align=center valign=middle>8%</td></tr><tr><td class=tlgrey>JPEG Compress MT</td><td align=center valign=middle>30.8 MPixels/s</td><td align=center valign=middle>33.3 MPixels/s</td><td align=center valign=middle>8%</td></tr><tr><td class=tlgrey>JPEG Decompress</td><td align=center valign=middle>36.0 MPixels/s</td><td align=center valign=middle>40.3 MPixels/s</td><td align=center valign=middle>11%</td></tr><tr><td class=tlgrey>JPEG Decompress MT</td><td align=center valign=middle>71.3 MPixels/s</td><td align=center valign=middle>78.1 MPixels/s</td><td align=center valign=middle>9%</td></tr><tr><td class=tlgrey>PNG Compress</td><td align=center valign=middle>0.84 MPixels/s</td><td align=center valign=middle>1.14 MPixels/s</td><td align=center valign=middle>35%</td></tr><tr><td class=tlgrey>PNG Compress MT</td><td align=center valign=middle>1.67 MPixels/s</td><td align=center valign=middle>2.26 MPixels/s</td><td align=center valign=middle>35%</td></tr><tr><td class=tlgrey>PNG Decompress</td><td align=center valign=middle>13.9 MPixels/s</td><td align=center valign=middle>15.2 MPixels/s</td><td align=center valign=middle>9%</td></tr><tr><td class=tlgrey>PNG Decompress MT</td><td align=center valign=middle>27.4 MPixels/s</td><td align=center valign=middle>29.8 MPixels/s</td><td align=center valign=middle>8%</td></tr><tr><td class=tlgrey>Sobel</td><td align=center valign=middle>59.3 MPixels/s</td><td align=center valign=middle>58.0 MPixels/s</td><td align=center valign=middle>-3%</td></tr><tr><td class=tlgrey>Sobel MT</td><td align=center valign=middle>116.6 MPixels/s</td><td align=center valign=middle>114.6 MPixels/s</td><td align=center valign=middle>-2%</td></tr><tr><td class=tlgrey>Lua</td><td align=center valign=middle>1.25 MB/s</td><td align=center valign=middle>1.33 MB/s</td><td align=center valign=middle>6%</td></tr><tr><td class=tlgrey>Lua MT</td><td align=center valign=middle>2.47 MB/s</td><td align=center valign=middle>2.49 MB/s</td><td align=center valign=middle>0%</td></tr><tr><td class=tlgrey>Dijkstra</td><td align=center valign=middle>5.35 MPairs/s</td><td align=center valign=middle>4.05 MPairs/s</td><td align=center valign=middle>-25%</td></tr><tr><td class=tlgrey>Dijkstra MT</td><td align=center valign=middle>9.67 MPairs/s</td><td align=center valign=middle>7.26 MPairs/s</td><td align=center valign=middle>-25%</td></tr></tbody></table><p>The AES and SHA1 gains are a direct result of the new cryptographic instructions that are a part of ARMv8. The AES test in particular shows nearly an order of magnitude performance improvement. This is similar to what we saw in the PC space with the introduction of Intel's AES-NI support in Westmere. The Dijkstra workload is the only real regression. That test in particular appears to be very pointer heavy, and the increase in pointer size from 32 to 64-bit increases cache pressure and causes the reduction in performance. The rest of the gains are much smaller, but still fairly significant if you take into account the fact that we're just looking at what you get from a recompile. Add these gains to the ones you're about to see over Apple's A6 SoC and A7 is looking really good from a performance standpoint.</p><p>If the integer results looked good, the FP results are even better:</p><table align=center border=0 cellpadding=0 cellspacing=1 width=575><tbody readability=1><tr class=tgrey readability=2><td align=center colspan=7>Apple A7 - AArch64 vs. AArch32 Performance Comparison</td></tr><tr class=tlblue><td width=120>&nbsp;</td><td align=center valign=middle width=85>32-bit A32</td><td align=center valign=middle width=85>64-bit A64</td><td align=center valign=middle width=85>% Advantage</td></tr><tr><td class=tlgrey>BlackScholes</td><td align=center valign=middle>4.73 MNodes/s</td><td align=center valign=middle>5.92 MNodes/s</td><td align=center valign=middle>25%</td></tr><tr><td class=tlgrey>BlackScholes MT</td><td align=center valign=middle>9.57 MNodes/s</td><td align=center valign=middle>12.0 MNodes/s</td><td align=center valign=middle>25%</td></tr><tr><td class=tlgrey>Mandelbrot</td><td align=center valign=middle>930.2 MFLOPS</td><td align=center valign=middle>929.9 MFLOPS</td><td align=center valign=middle>0%</td></tr><tr><td class=tlgrey>Mandelbrot</td><td align=center valign=middle>1840 MFLOPS</td><td align=center valign=middle>1850 MFLOPS</td><td align=center valign=middle>0%</td></tr><tr><td class=tlgrey>Sharpen Filter</td><td align=center valign=middle>805.1 MFLOPS</td><td align=center valign=middle>857 MFLOPS</td><td align=center valign=middle>6%</td></tr><tr><td class=tlgrey>Sharpen Filter MT</td><td align=center valign=middle>1610 MFLOPS</td><td align=center valign=middle>1710 MFLOPS</td><td align=center valign=middle>6%</td></tr><tr><td class=tlgrey>Blur Filter</td><td align=center valign=middle>1.08 GFLOPS</td><td align=center valign=middle>1.26 GFLOPS</td><td align=center valign=middle>16%</td></tr><tr><td class=tlgrey>Blur Filter MT</td><td align=center valign=middle>2.15 GFLOPS</td><td align=center valign=middle>2.47 GFLOPS</td><td align=center valign=middle>14%</td></tr><tr><td class=tlgrey>SGEMM</td><td align=center valign=middle>3.09 GFLOPS</td><td align=center valign=middle>3.34 GFLOPS</td><td align=center valign=middle>8%</td></tr><tr><td class=tlgrey>SGEMM MT</td><td align=center valign=middle>6.08 GFLOPS</td><td align=center valign=middle>6.56 GFLOPS</td><td align=center valign=middle>7%</td></tr><tr><td class=tlgrey>DGEMM</td><td align=center valign=middle>0.56 GFLOPS</td><td align=center valign=middle>1.66 GFLOPS</td><td align=center valign=middle>195%</td></tr><tr><td class=tlgrey>DGEMM MT</td><td align=center valign=middle>1.11 GFLOPS</td><td align=center valign=middle>3.24 GFLOPS</td><td align=center valign=middle>191%</td></tr><tr><td class=tlgrey>SFFT</td><td align=center valign=middle>0.72 GFLOPS</td><td align=center valign=middle>1.59 GFLOPS</td><td align=center valign=middle>119%</td></tr><tr><td class=tlgrey>SFFT MT</td><td align=center valign=middle>1.44 GFLOPS</td><td align=center valign=middle>3.17 GFLOPS</td><td align=center valign=middle>120%</td></tr><tr><td class=tlgrey>DFFT</td><td align=center valign=middle>1.41 GFLOPS</td><td align=center valign=middle>1.47 GFLOPS</td><td align=center valign=middle>4%</td></tr><tr><td class=tlgrey>DFFT MT</td><td align=center valign=middle>2.78 GFLOPS</td><td align=center valign=middle>2.91 GFLOPS</td><td align=center valign=middle>4%</td></tr><tr><td class=tlgrey>N-Body</td><td align=center valign=middle>460.8 KPairs/s</td><td align=center valign=middle>582.6 KPairs/s</td><td align=center valign=middle>26%</td></tr><tr><td class=tlgrey>N-Body MT</td><td align=center valign=middle>917.6 KPairs/s</td><td align=center valign=middle>1160.0 KPairs/s</td><td align=center valign=middle>26%</td></tr><tr><td class=tlgrey>Ray Trace</td><td align=center valign=middle>1.52 MPixels/s</td><td align=center valign=middle>2.31 MPixels/s</td><td align=center valign=middle>51%</td></tr><tr><td class=tlgrey>Ray Trace MT</td><td align=center valign=middle>3.04 MPixels/s</td><td align=center valign=middle>4.64 MPixels/s</td><td align=center valign=middle>52%</td></tr></tbody></table><p>The DGEMM operations aren't vectorized under ARMv7, but they are under ARMv8 thanks to DP SIMD support so you get huge speedups there from the recompile. The SFFT workload benefits handsomely from the increased register space, significantly reducing the number of loads and stores (there's something like a 30% reduction in instructions for the A64 codepath compared to the A32 codepath here). The conclusion? There are definitely reasons outside of needing more memory to go 64-bit.</p><h2>A7 and OS X</h2><p>Before I spent time with the A7 I assumed the only reason Apple would go 64-bit in mobile is to prepare for eventually deploying these chips into larger machines. A couple of years ago, when the Apple/Intel relationship was at its rockiest I would've definitely said that's what was going on. Today, I'm far less convinced.&nbsp;</p><p>Apple continues to build its own SoCs and invest in them because honestly, no one else seems up to the job. Only recently do we have GPUs competitive with what Apple has been shipping, and with the A7 Apple nearly equals Intel's performance with Bay Trail on the CPU side. As far as Macs go though, there's still a big gap between the A7 and where Intel is at with Haswell. The deficiency that Intel had in the ultra mobile space simply doesn't translate to its position with the big Core chips. I don't see Apple bridging that gap anytime soon. On top of that, the Apple/Intel relationship is very good at this point.</p><p>Although Apple could conceivably keep innovating to the point where an A-series chip ends up powering a Mac, I don't think that's in the cards today.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZIR0f5Roq6GdXZ69qbvNnmRuq12nsre1xLBmbQ%3D%3D</p></section></article></main></div><footer><div class=container><span class=copyright>&copy; 2024 ZingW - <a rel=license href=http://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a></span></div></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>